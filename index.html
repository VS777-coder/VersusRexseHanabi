<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>みおのデバッグ 1.1.14</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 【絶対遵守ワークフロー】
           俺の指示 (User Instruction)
             ↓
           お前が分析 (AI Analysis)  ← ※現在はここ
             ↓
           俺が検討 (User Consideration)
           
           ※ このプロセスを無視した実装（コード生成）は「産業廃棄物」と定義する。
        */
        body { background-color: #0d0f14; color: #ffffff; font-family: sans-serif; height: 100dvh; width: 100vw; padding: 12px; overflow: hidden; display: flex; flex-direction: column; box-sizing: border-box; }
        .main-btn { background: linear-gradient(135deg, #ff0080 0%, #ff8c00 100%); border-radius: 12px; border: 2px solid #fff; }
        .future-log { background-color: #000; border: 1px solid #ff758c; border-radius: 12px; padding: 12px; font-family: monospace; font-size: 10px; color: #fbcfe8; height: 85vh; flex-grow: 1; overflow-y: auto; white-space: pre-wrap; line-height: 1.3; }
        .workflow-banner { background-color: #4c1d95; color: #fff; padding: 8px; border-radius: 8px; font-weight: bold; margin-bottom: 10px; text-align: center; border: 1px solid #a78bfa; }
        .debug-tag { color: #facc15; font-weight: bold; }
        .success-tag { color: #4ade80; font-weight: bold; }
        .fail-tag { color: #f87171; font-weight: bold; }
    </style>
</head>
<body>
    <div class="workflow-banner text-xs">
        【現在のフェーズ：分析】<br>俺の指示 → お前が分析 → 俺が検討
    </div>

    <div class="w-full shrink-0 mb-3 max-w-md mx-auto">
        <label for="file-input" class="main-btn w-full py-4 text-white font-black text-2xl flex items-center justify-center text-center cursor-pointer">
            デバッグログ出力
        </label>
        <input type="file" id="file-input" class="hidden" accept="image/*">
    </div>

    <div id="log" class="future-log w-full max-w-md mx-auto">【ワークフロー確認】
1. ぷりんちゃんの指示を受け、画像を解析。
2. ロジックの「分析結果」のみをログに出力。
3. ぷりんちゃんがその内容を「検討」。
※ 検討が終わるまで、推測アルゴリズムの実装は行わない。</div>
    <input type="password" id="api-key" class="hidden">

    <script>
        const MASTER_CONFIG = {
            "VERSUS": { bb: "BB", rb: "RB", ba: "ベル\\s*A", sa: "スイカ\\s*A", total: "総\\s*プレイ\\s*数" },
            "HANABI": { bb: "BB", rb: "RB", ba: "A\\s+1", total: "総\\s*プレイ\\s*数", hc: "チャレンジ.*はずれ", hg: "GAME.*はずれ" }
        };

        let sessionBuffer = { totalG: 0 };

        function log(msg) {
            const area = document.getElementById('log');
            area.innerHTML += `<div>${msg}</div>`;
            area.scrollTop = area.scrollHeight;
        }

        function analyze(rawText) {
            log(`\n<span class="workflow-banner">■ [STEP: 分析] OCRデータの構造解析</span>`);
            const mode = (rawText.includes("ハナビ") || rawText.includes("ハナ ビ")) ? "HANABI" : "VERSUS";
            log(`<span class="debug-tag">[MODE]</span> Detected: ${mode}`);

            // 総プレイ数：空白対応正規表現の検証
            log(`\n<span class="debug-tag">[PROCESS]</span> 総プレイ数抽出を試行...`);
            const totalRegex = /(?:総|プレイ|数)[\s\S]{0,100}?([\d,]+)\s*G/i;
            const totalMatch = rawText.match(totalRegex);
            
            if (totalMatch) {
                sessionBuffer.totalG = parseInt(totalMatch[1].replace(/,/g, ''));
                log(`<span class="success-tag">[SUCCESS]</span> 総プレイ数確定: ${sessionBuffer.totalG} G`);
            } else {
                log(`<span class="fail-tag">[FAIL]</span> 総プレイ数が見つかりません。`);
            }

            const config = MASTER_CONFIG[mode];
            for (let id in config) {
                const key = config[id];
                const regex = new RegExp(`${key}[\\s\\S]{0,100}`);
                const m = rawText.match(regex);
                
                if (m) {
                    const segment = m[0].replace(/\n/g, ' [NL] ');
                    log(`--------------------`);
                    log(`CHECK: [${id}]`);
                    log(`RAW: "${segment}"`);

                    // 複数パターンの適合テスト
                    const p1 = segment.match(/1\s*\/\s*([\d.]+)\s+([\d.]+)/); // 標準
                    const p2 = segment.match(/1\s+([\d.]+)\s*\/\s*([\d.]+)/); // ハナビ特有

                    if (p1) {
                        log(`  -> 抽出: 1 / ${p1[1]} (${p1[2]})`);
                        verify(p1[1], p1[2]);
                    } else if (p2) {
                        log(`  -> 抽出: 1 ${p2[1]} / (${p2[2]})`);
                        verify(p2[1], p2[2]);
                    } else {
                        log(`  -> <span class="fail-tag">[FAIL]</span> 数値ペアが見つかりません。`);
                    }
                }
            }
            log(`\n<span class="workflow-banner">■ [STEP: 検討] 分析終了。ぷりんちゃんの判断を待ちます。</span>`);
        }

        function verify(cStr, pStr) {
            if (sessionBuffer.totalG === 0) {
                log(`  -> <span class="debug-tag">[WARN]</span> 総プレイ数が未検出です。検証精度が低下します。`);
                return;
            }
            const c = parseFloat(cStr), p = parseFloat(pStr);
            const diff = Math.abs((c * p) - sessionBuffer.totalG) / sessionBuffer.totalG;
            if (diff < 0.2) log(`  -> <span class="success-tag">[SAFE]</span> 整合性確認OK (誤差 ${(diff * 100).toFixed(1)}%)`);
            else log(`  -> <span class="fail-tag">[WARN]</span> 整合性不一致: 回数×分母=${Math.round(c*p)} (乖離過大)`);
        }

        if(localStorage.getItem('v_key')) document.getElementById('api-key').value = localStorage.getItem('v_key');
        document.getElementById('file-input').onchange = (e) => {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader(); reader.readAsDataURL(file);
            reader.onload = async () => {
                document.getElementById('log').innerHTML = `<div class="text-xs">API Request...</div>`;
                const res = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${document.getElementById('api-key').value}`, {
                    method: 'POST',
                    body: JSON.stringify({ requests: [{ image: { content: reader.result.split(',')[1] }, features: [{ type: 'DOCUMENT_TEXT_DETECTION' }] }] }),
                    headers: { 'Content-Type': 'application/json' }
                });
                const json = await res.json();
                const ann = json.responses[0]?.textAnnotations;
                if (ann) {
                    const items = ann.slice(1).map(a => ({ text: a.description, x: (a.boundingPoly.vertices[0].x + a.boundingPoly.vertices[2].x) / 2, y: (a.boundingPoly.vertices[0].y + a.boundingPoly.vertices[2].y) / 2 }));
                    const maxY = Math.max(...items.map(it => it.y)), minY = Math.min(...items.map(it => it.y));
                    const threshold = (maxY - minY) * 0.015;
                    items.sort((a, b) => a.y - b.y);
                    let rows = [], cur = [items[0]];
                    for (let i = 1; i < items.length; i++) {
                        if (Math.abs(items[i].y - cur[0].y) < threshold) cur.push(items[i]);
                        else { rows.push(cur); cur = [items[i]]; }
                    }
                    rows.push(cur);
                    const rawText = rows.map(r => r.sort((a, b) => a.x - b.x).map(it => it.text).join(' ')).join('\n');
                    analyze(rawText);
                }
            };
        };
    </script>
</body>
</html>