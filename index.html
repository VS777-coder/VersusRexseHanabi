<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ANALYZER Rev 2.1.6</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Squada+One&display=swap');
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { background-color: #1a1614; color: #f3e8d2; font-family: 'Inter', sans-serif; height: 100dvh; width: 100%; margin: 0; padding: 12px; overflow: hidden; display: flex; flex-direction: column; }
        .kawaii-title { font-family: 'Squada One', cursive; color: #f59e0b; font-size: 2.2rem; line-height: 1.0; text-align: center; }
        .main-btn { background-color: #78350f; border: 2px solid #f59e0b; border-radius: 12px; cursor: pointer; height: 60px; display: flex; align-items: center; justify-content: center; width: 100%; margin-bottom: 8px; flex-shrink: 0; }
        .result-card { background-color: #2d241e; border-radius: 12px; padding: 10px; border: 1px solid #78350f; margin-bottom: 8px; flex-shrink: 0; }
        .bar-bg { background-color: #1a1614; height: 8px; border-radius: 4px; overflow: hidden; margin-top: 2px; border: 1px solid #451a03; }
        .bar-fill { height: 100%; width: 0%; transition: width 0.8s cubic-bezier(0.22, 1, 0.36, 1); }
        .log-container { flex-grow: 1; min-height: 0; position: relative; margin-bottom: 4px; display: flex; flex-direction: column; }
        .future-log { background-color: #0c0a09; border: 1px solid #78350f; border-radius: 8px; padding: 10px; font-family: 'Share Tech Mono', monospace; font-size: 9px; width: 100%; height: 100%; overflow-y: auto; white-space: pre-wrap; color: #ffffff; line-height: 1.5; }
        .copy-btn { position: absolute; top: 8px; right: 8px; background: #b45309; color: #fef3c7; font-size: 10px; padding: 6px 12px; border-radius: 4px; cursor: pointer; border: none; z-index: 10; }
        .api-footer { flex-shrink: 0; display: flex; gap: 8px; padding-bottom: 2px; }
        .api-input { background-color: #2d241e; color: #fef3c7; border-radius: 6px; padding: 8px 10px; font-size: 11px; flex-grow: 1; border: 1px solid #78350f; outline: none; }
    </style>
</head>
<body>
    <div class="header-area">
        <div class="kawaii-title">ANALYZER REV 2.1.6</div>
        <div class="text-[9px] font-bold text-amber-800 text-center mb-1">STABLE PHYSICAL AUTO-REPAIR</div>
    </div>
    <div class="shrink-0"><label for="file-input" class="main-btn"><span class="text-white text-2xl font-black">解析実行</span></label><input type="file" id="file-input" class="hidden" accept="image/*" multiple></div>
    <div id="result-area" class="result-card">
        <div class="mb-2"><div class="flex justify-between text-[11px] font-bold text-amber-400"><span>設定1</span><span id="p1">---</span></div><div class="bar-bg"><div id="b1" class="bar-fill bg-amber-400"></div></div></div>
        <div class="mb-2"><div class="flex justify-between text-[11px] font-bold text-amber-500"><span>設定2</span><span id="p2">---</span></div><div class="bar-bg"><div id="b2" class="bar-fill bg-amber-500"></div></div></div>
        <div class="mb-2"><div class="flex justify-between text-[11px] font-bold text-orange-600"><span>設定5</span><span id="p5">---</span></div><div class="bar-bg"><div id="b5" class="bar-fill bg-orange-600"></div></div></div>
        <div><div class="flex justify-between text-[11px] font-bold text-red-600"><span>設定6</span><span id="p6">---</span></div><div class="bar-bg"><div id="b6" class="bar-fill bg-red-600"></div></div></div>
    </div>
    <div class="log-container"><button id="copy-log" class="copy-btn">COPY</button><div id="log" class="future-log">READY...</div></div>
    <div class="api-footer"><input type="password" id="api-key" class="api-input" placeholder="VISION API KEY"><button id="save-key" class="bg-amber-900 text-amber-200 px-4 rounded">SAVE</button></div>

<script>
    // 定義表 (完全固定)
    const L_HANABI_CONFIG = [
        { id: "total", name: "ボーナス合算", active: false, type: "normal", probs: {1:1,2:1,5:1,6:1} },
        { id: "bb", name: "ビックボーナス", active: true, type: "normal", probs: {1: 297.9, 2: 292.6, 5: 284.9, 6: 273.1} },
        { id: "don", name: "ドンBB", active: false, type: "normal", probs: {1:1,2:1,5:1,6:1} },
        { id: "red7", name: "赤七BB", active: false, type: "normal", probs: {1:1,2:1,5:1,6:1} },
        { id: "rb", name: "レギュラーボーナス", active: true, type: "normal", probs: {1: 394.8, 2: 358.1, 5: 313.6, 6: 282.5} },
        { id: "f_tot", name: "風鈴合算", active: false, type: "normal", probs: {1:1,2:1,5:1,6:1} },
        { id: "ba", name: "風鈴Ａ", active: true, type: "normal", probs: {1: 12.9, 2: 12.5, 5: 12.1, 6: 11.5} },
        { id: "bb_b", name: "風鈴Ｂ", active: true, type: "normal", probs: {1: 38.4, 2: 38.7, 5: 36.2, 6: 34.5} },
        { id: "i_tot", name: "氷合算", active: false, type: "normal", probs: {1:1,2:1,5:1,6:1} },
        { id: "ia", name: "氷Ａ", active: true, type: "normal", probs: {1: 46.3, 2: 47.3, 5: 46.2, 6: 47.4} },
        { id: "ib", name: "氷Ｂ", active: false, type: "normal", probs: {1:1,2:1,5:1,6:1} },
        { id: "c_tot", name: "チェリー合算", active: false, type: "normal", probs: {1:1,2:1,5:1,6:1} },
        { id: "ca1", name: "チェリーＡ１", active: false, type: "normal", probs: {1:1,2:1,5:1,6:1} },
        { id: "ca2", name: "チェリーＡ２", active: true, type: "normal", probs: {1: 21.0, 2: 19.4, 5: 20.5, 6: 19.6} },
        { id: "cb", name: "チェリーＢ", active: true, type: "normal", probs: {1: 307.7, 2: 306.2, 5: 300.6, 6: 297.9} },
        { id: "vc", name: "ハナビチャレンジ中ハズレ", active: true, type: "vc", probs: {1: 4.7, 2: 4.5, 5: 4.3, 6: 4.2} },
        { id: "vg", name: "ハナビゲーム中ハズレ", active: true, type: "vg", probs: {1: 6.4, 2: 6.0, 5: 5.4, 6: 5.4} },
        { id: "b_ba", name: "BIG中風鈴Ａ", active: true, type: "big", probs: {1: 1.1, 2: 1.2, 5: 1.1, 6: 1.2} },
        { id: "b_bb", name: "BIG中風鈴Ｂ", active: true, type: "big", probs: {1: 10.0, 2: 7.0, 5: 10.0, 6: 7.0} }
    ];

    const HANABI_CONFIG = [
        { id: "total", name: "ボーナス合算", active: false, type: "normal", probs: {1:1,2:1,5:1,6:1} },
        { id: "bb", name: "ビックボーナス", active: true, type: "normal", probs: {1: 277.7, 2: 268.6, 5: 256.0, 6: 248.2} },
        { id: "don", name: "ドンBB", active: false, type: "normal", probs: {1:1,2:1,5:1,6:1} },
        { id: "red", name: "赤七BB", active: false, type: "normal", probs: {1:1,2:1,5:1,6:1} },
        { id: "rb", name: "レギュラーボーナス", active: true, type: "normal", probs: {1: 356.2, 2: 331.0, 5: 306.2, 6: 280.1} },
        { id: "f_tot", name: "風鈴合算", active: false, type: "normal", probs: {1:1,2:1,5:1,6:1} },
        { id: "ba", name: "風鈴Ａ", active: true, type: "normal", probs: {1: 15.6, 2: 15.3, 5: 15.1, 6: 14.9} },
        { id: "bb_b", name: "風鈴Ｂ", active: true, type: "normal", probs: {1: 15.3, 2: 14.9, 5: 14.7, 6: 13.8} },
        { id: "i_tot", name: "氷合算", active: false, type: "normal", probs: {1:1,2:1,5:1,6:1} },
        { id: "ia", name: "氷Ａ", active: true, type: "normal", probs: {1: 54.6, 2: 59.6, 5: 51.2, 6: 54.6} },
        { id: "ib", name: "氷Ｂ", active: false, type: "normal", probs: {1:1,2:1,5:1,6:1} },
        { id: "c_tot", name: "チェリー合算", active: false, type: "normal", probs: {1:1,2:1,5:1,6:1} },
        { id: "ca1", name: "チェリーＡ１", active: false, type: "normal", probs: {1:1,2:1,5:1,6:1} },
        { id: "ca2", name: "チェリーＡ２", active: true, type: "normal", probs: {1: 21.0, 2: 19.3, 5: 20.6, 6: 19.9} },
        { id: "cb", name: "チェリーＢ", active: true, type: "normal", probs: {1: 282.5, 2: 281.3, 5: 276.5, 6: 274.2} },
        { id: "vc", name: "ハナビチャレンジ中ハズレ", active: true, type: "vc", probs: {1: 6.6, 2: 6.2, 5: 5.8, 6: 5.3} },
        { id: "vg", name: "ハナビゲーム中ハズレ", active: true, type: "vg", probs: {1: 11.7, 2: 10.8, 5: 10.0, 6: 9.4} },
        { id: "pf", name: "平行風鈴", active: false, type: "big", probs: {1: 1.1, 2: 1.13, 5: 1.1, 6: 1.13} },
        { id: "nf", name: "斜め風鈴", active: true, type: "big", probs: {1: 11.0, 2: 9.0, 5: 11.0, 6: 9.0} }
    ];

    const VERSUS_CONFIG = [
        { id: "total", name: "ボーナス合算", active: false, type: "normal", probs: {1:1,2:1,5:1,6:1} },
        { id: "bb", name: "ビックボーナス合算", active: true, type: "normal", probs: {1: 292.6, 2: 284.9, 5: 275.4, 6: 264.3} },
        { id: "rb", name: "レギュラーボーナス", active: true, type: "normal", probs: {1: 374.5, 2: 341.3, 5: 319.7, 6: 292.6} },
        { id: "ba", name: "ベルＡ", active: true, type: "normal", probs: {1: 10.9, 2: 10.7, 5: 10.5, 6: 10.2} },
        { id: "bb_b", name: "ベルＢ", active: true, type: "normal", probs: {1: 20.9, 2: 21.2, 5: 20.3, 6: 20.6} },
        { id: "sa", name: "スイカＡ", active: true, type: "normal", probs: {1: 74.5, 2: 70.6, 5: 72.5, 6: 68.8} },
        { id: "cb", name: "チェリーＢ", active: true, type: "normal", probs: {1: 56.2, 2: 57.7, 5: 53.1, 6: 54.4} },
        { id: "vc", name: "バーサスチャンス中ハズレ", active: true, type: "vc", probs: {1: 5.0, 2: 4.9, 5: 4.6, 6: 4.5} },
        { id: "vg", name: "バーサスゲーム中ハズレ", active: true, type: "vg", probs: {1: 10.1, 2: 9.4, 5: 8.7, 6: 8.1} },
        { id: "cbs", name: "チェリー＋ベル揃い", active: true, type: "big", probs: {1: 11.1, 2: 8.9, 5: 11.1, 6: 8.9} },
        { id: "cbh", name: "チェリー＋ベルはずれ", active: true, type: "big", probs: {1: 256.0, 2: 128.0, 5: 256.0, 6: 128.0} }
    ];

    const logArea = document.getElementById('log');
    const addLog = (m, c="text-white") => { const e=document.createElement('div'); e.className=c; e.innerHTML=m; logArea.appendChild(e); logArea.scrollTop=logArea.scrollHeight; };
    const titleLog = (m) => addLog(`\n${m}`, "text-yellow-500 font-bold underline");

    async function processAnalysis(files) {
        const key = document.getElementById('api-key').value.trim();
        if(!key) { alert("API KEY REQUIRED"); return; }
        logArea.innerHTML = "";
        addLog(`>> SYSTEM BOOT: ANALYZER Rev 2.1.6`, "text-amber-400 font-bold");

        try {
            titleLog(`（１）画像情報`);
            let rawDatas = [];
            for (let file of Array.from(files)) {
                addLog(`TARGET_FILE: ${file.name} / ${Math.round(file.size/1024)}KB`);
                const base64 = await new Promise(res => { const r = new FileReader(); r.onload = e => res(e.target.result.split(',')[1]); r.readAsDataURL(file); });
                const resp = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${key}`, { method: 'POST', body: JSON.stringify({ requests: [{ image: { content: base64 }, features: [{ type: 'DOCUMENT_TEXT_DETECTION' }] }] }) });
                const json = await resp.json();
                const lines = json.responses[0].textAnnotations.slice(1).reduce((acc, w) => {
                    let y = w.boundingPoly.vertices[0].y;
                    let row = acc.find(r => Math.abs(r.y - y) <= 10);
                    if (row) row.words.push({x: w.boundingPoly.vertices[0].x, text: w.description});
                    else acc.push({ y, words: [{x: w.boundingPoly.vertices[0].x, text: w.description}] });
                    return acc;
                }, []).sort((a, b) => a.y - b.y).map(line => ({ text: line.words.sort((a, b) => a.x - b.x).map(w => w.text).join(" "), y: line.y }));
                rawDatas.push({ file: file.name, lines });
            }

            titleLog(`（２）画像順序・接着判定`);
            const sorted = rawDatas.sort((a, b) => {
                const aG = a.lines.some(l => l.text.includes("G"));
                const bG = b.lines.some(l => l.text.includes("G"));
                return bG - aG;
            });
            sorted.forEach((img, i) => addLog(`[SORT] Index[${i}]: ${img.file} ${img.lines.some(l=>l.text.includes("G"))?'(BASE)':''}`));

            titleLog(`（３）画像別の生データ`);
            sorted.forEach((img, i) => {
                addLog(`--- IMAGE[${i}] RAW ---`, "text-amber-200 text-[8px]");
                img.lines.forEach((l, li) => addLog(`[RAW] #${li.toString().padStart(2,'0')} Y:${l.y} | ${l.text}`, "text-gray-500 text-[7px]"));
            });

            titleLog(`（４）機種判定 & G-GATE`);
            let baseLines = sorted[0].lines;
            let headTxt = baseLines.slice(0, 15).map(l=>l.text).join("");
            let isSmaslo = headTxt.includes("スマスロ");
            let isVersus = headTxt.includes("バーサス");
            let machine = isSmaslo ? {def:L_HANABI_CONFIG, name:"スマスロ", bG:20} :
                          isVersus ? {def:VERSUS_CONFIG, name:"バーサス", bG:28} : {def:HANABI_CONFIG, name:"新ハナビ", bG:29};
            addLog(`DETECTED: 【${machine.name}】`);

            let totalG = 0, vcG = 0, vgG = 0, gateIdx = -1;
            let gCountFound = 0;
            for(let i=0; i<Math.min(baseLines.length, 30); i++) {
                const gs = baseLines[i].text.match(/([\d,]+)G/g);
                if(gs) {
                    const nums = gs.map(s => parseInt(s.replace(/[,G]/g,'')));
                    if(isSmaslo) {
                        nums.forEach(n => {
                            gCountFound++;
                            if(gCountFound === 1) totalG = n;
                            if(gCountFound === 2) vcG = n;
                            if(gCountFound === 3) { vgG = n; gateIdx = i; }
                        });
                    } else if(totalG === 0) { totalG = nums[0]; gateIdx = i; }
                }
                if(gateIdx !== -1) break;
            }
            if(gateIdx === -1) throw new Error("G-GATE NOT FOUND");
            addLog(`G-GATE OPEN at Index[0]:#${gateIdx} (Total:${totalG} / VC:${vcG} / VG:${vgG})`);

            titleLog(`（５）仮想配列作成（物理マッピング・自己修復）`);
            let unified = [];
            sorted.forEach((img, idx) => {
                if(idx === 0) {
                    img.lines.slice(gateIdx + 1).forEach((l, li) => unified.push({ text: l.text, imgIdx: 0, lineIdx: gateIdx + 1 + li }));
                } else {
                    let lastProb = [...unified].reverse().find(l => l.text.includes("/"));
                    let matchIdx = img.lines.findIndex(l => lastProb && l.text.includes(lastProb.text));
                    if(matchIdx !== -1) {
                        addLog(`[JOIN] ${img.file} 接着点(IMG${idx}:#${matchIdx}) 「${lastProb.text}」`);
                        img.lines.slice(matchIdx + 1).forEach((l, li) => unified.push({ text: l.text, imgIdx: idx, lineIdx: matchIdx + 1 + li }));
                    }
                }
            });

            let vArr = [];
            unified.forEach((line, i) => {
                if(line.text.includes("/") && (line.text.includes(".") || line.text.includes("-"))) {
                    const findK = (idx) => {
                        for(let j=1; j<=4; j++) {
                            const m = unified[idx-j]?.text.replace(/[,回]/g,'').match(/^\d+/);
                            if(m) return {k:parseInt(m[0]), pos:`IMG${unified[idx-j].imgIdx}:#${unified[idx-j].lineIdx}`};
                        } return null;
                    };
                    let kRes = findK(i);
                    let rawP = line.text.split("/")[1] || "0";
                    let pVal = line.text.includes("-") ? 999999 : parseFloat(rawP.replace(/,/g, ''));
                    
                    if(kRes) {
                        // 【物理規律：自己修復機能】
                        let currentSlot = machine.def[vArr.length];
                        let nRef = totalG;
                        if(currentSlot?.type === "vc") nRef = isSmaslo ? vcG : Math.round(kRes.k * pVal);
                        if(currentSlot?.type === "vg") nRef = isSmaslo ? vgG : Math.round(kRes.k * pVal);
                        if(currentSlot?.type === "big") nRef = (vArr[1]?.k || 0) * machine.bG;

                        let kCalc = Math.round(nRef / pVal);
                        let finalK = kRes.k;
                        if(Math.abs(kRes.k - kCalc) > 2) {
                            addLog(`⚠️ ALERT: ${currentSlot?.name} 誤読補正 [OCR:${kRes.k} → CALC:${kCalc}] (1/${pVal.toFixed(1)})`, "text-red-400");
                            finalK = kCalc;
                        }
                        vArr.push({ k: finalK, p: pVal, kPos: kRes.pos, pPos: `IMG${line.imgIdx}:#${line.lineIdx}` });
                    } else {
                        vArr.push(null);
                        addLog(`[MAP] 1/${pVal.toFixed(1)} -> ⚠️回数不明`, "text-red-400");
                    }
                }
            });

            titleLog(`（６）定義表当て込み （７）尤度計算`);
            let lls = {1:0, 2:0, 5:0, 6:0};
            let bbCount = vArr[1]?.k || 0;

            machine.def.forEach((slot, si) => {
                let data = vArr[si];
                if(!data) return;
                let n = totalG;
                if(slot.type === "vc") n = isSmaslo ? vcG : Math.round(data.k * data.p);
                if(slot.type === "vg") n = isSmaslo ? vgG : Math.round(data.k * data.p);
                if(slot.type === "big") n = bbCount * machine.bG;

                addLog(`${slot.name.padEnd(12)} | ${data.k}回 : 1/${data.p.toFixed(1)} (N=${n})`);
                if(slot.active && n > 0 && data.p < 99999) {
                    let itemLLs = {1:0, 2:0, 5:0, 6:0};
                    [1,2,5,6].forEach(s => {
                        let tp = 1 / slot.probs[s];
                        let ll = (data.k * Math.log(tp) + (n - data.k) * Math.log(1 - tp));
                        itemLLs[s] = ll; lls[s] += ll;
                    });
                    const maxI = Math.max(...Object.values(itemLLs));
                    [1,2,5,6].forEach(s => {
                        let gap = maxI - itemLLs[s];
                        addLog(`  [設定${s}] ${gap < 0.1 ? '★★★★★' : gap < 0.5 ? '★★★★☆' : '★★★☆☆'} (Gap:${gap.toFixed(3)})`, "text-gray-500 text-[8px]");
                    });
                }
            });

            titleLog(`（８）設定判別処理（最終）`);
            const maxL = Math.max(...Object.values(lls));
            const sumExp = Object.values(lls).reduce((a, l) => a + Math.exp(l - maxL), 0);
            [1,2,5,6].forEach(s => {
                let prob = (Math.exp(lls[s] - maxL) / sumExp) * 100;
                document.getElementById(`p${s}`).innerText = prob.toFixed(1) + "%";
                document.getElementById(`b${s}`).style.width = prob + "%";
                addLog(`SETTING ${s}: ${prob.toFixed(2).padStart(6)}% | 総GAP: ${(maxL - lls[s]).toFixed(4)}`, s === 6 ? "text-red-400" : "text-white");
            });
            addLog(`\nInference cycle terminated.`);
        } catch (e) { addLog(`❌ ERROR: ${e.message}`, "text-red-600"); }
    }

    document.getElementById('save-key').onclick = () => { localStorage.setItem('v_key', document.getElementById('api-key').value); alert("KEY SAVED"); };
    window.onload = () => { document.getElementById('api-key').value = localStorage.getItem('v_key') || ''; };
    document.getElementById('copy-log').onclick = () => { const r = document.createRange(); r.selectNode(logArea); window.getSelection().removeAllRanges(); window.getSelection().addRange(r); document.execCommand('copy'); alert("COPIED"); };
    document.getElementById('file-input').onchange = e => processAnalysis(e.target.files);
</script>
</body>
</html>