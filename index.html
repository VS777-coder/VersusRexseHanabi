function extractData(rawText) {
    sessionBuffer.activeMode = (rawText.includes("ハナビ") || rawText.includes("ハナ ビ")) ? "HANABI" : "VERSUS";
    const config = MASTER_CONFIG[sessionBuffer.activeMode];
    sessionBuffer.extracted = {};
    let logHtml = `■ 内部バッファ (${sessionBuffer.activeMode})\n<table>`;

    // 【P0】総プレイ数を絶対に見逃さない (Gの前の数字を広域スキャン)
    const gRegex = /([\d,]+)\s*G/i;
    const gMatch = rawText.match(gRegex);
    sessionBuffer.totalG = gMatch ? parseInt(gMatch[1].replace(/,/g, '')) : 0;

    // もしラベル「総プレイ数」の近くに別の数字があれば上書きを試みる
    const labelMatch = rawText.match(/(?:総|プレイ|数)[\s\S]{0,100}?([\d,]+)/);
    if (labelMatch && !gMatch) {
        sessionBuffer.totalG = parseInt(labelMatch[1].replace(/,/g, ''));
    }

    for (let id in config) {
        if (id === "name" || id === "total") continue;
        const item = config[id];
        let searchText = rawText;
        if (item.anchor) {
            const am = rawText.match(new RegExp(item.anchor));
            if (am) searchText = rawText.substring(am.index);
        }

        const regex = new RegExp(`${item.key}[\\s\\S]{0,120}`);
        const m = searchText.match(regex);
        if (m) {
            const segment = m[0];
            const p1 = segment.match(/1\s*\/\s*([\d,.]+)\s+([\d,.]+)/);
            const p2 = segment.match(/1\s+([\d,.]+)\s*\/\s*([\d,.]+)/);
            
            let c = null, p = null;
            if (p1) { c = p1[1]; p = p1[2]; }
            else if (p2) { c = p2[1]; p = p2[2]; }
            
            if (c && p) {
                let count = parseFloat(c.replace(/,/g, ''));
                let prob = parseFloat(p.replace(/,/g, ''));
                
                // 数値特性による自動スワップ
                if (count > prob && prob > 1.2) { [count, prob] = [prob, count]; }

                // データをバッファに格納 (指示通り、棄却は廃止)
                sessionBuffer.extracted[id] = { prob: prob, count: Math.round(count) };
                
                logHtml += `<tr><td>${item.label}</td><td>${Math.round(count)}回</td><td>1/${prob}</td></tr>`;
            }
        }
    }

    logHtml = `<tr><td>総プレイ数(確定)</td><td colspan="2">${sessionBuffer.totalG} G</td></tr>` + logHtml;
    document.getElementById('log').innerHTML = logHtml + `</table>`;
    runBayesian();
}

function runBayesian() {
    const config = MASTER_CONFIG[sessionBuffer.activeMode];
    let logL = { 1: 0, 2: 0, 5: 0, 6: 0 };
    const bbCount = sessionBuffer.extracted['bb']?.count || 0;

    for (let id in sessionBuffer.extracted) {
        const data = sessionBuffer.extracted[id];
        const item = config[id];
        if (!item || !data.prob) continue;

        [1, 2, 5, 6].forEach(s => {
            const pExp = 1 / item.vals[s];
            let n, k;

            // 【指示事項】RT項目の試行ゲーム数計算
            if (['vc', 'hc'].includes(id)) {
                // VC/HC: 指示通り 11.8 * BB回数を分母とする
                n = bbCount * 11.8;
                k = data.count;
            } else if (['vg', 'hg'].includes(id)) {
                // VG/HG: 回数 * 分母 から区間ゲーム数を算出
                n = data.count * data.prob;
                k = data.count;
            } else {
                // 通常時: 総プレイ数を使用
                n = sessionBuffer.totalG;
                k = data.count;
            }

            if (n > 0) {
                logL[s] += (k * Math.log(pExp) + (n - k) * Math.log(1 - pExp));
            }
        });
    }
    // ... (以下、確率変換処理)
}