<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HANABI & VERSUS Rev 1.2.14 (Physical Pointer)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Squada+One&display=swap');
        body { background-color: #0b0d11; color: #ffffff; font-family: 'Inter', sans-serif; height: 100dvh; margin: 0; padding: 12px; display: flex; flex-direction: column; overflow: hidden; }
        .kawaii-title { font-family: 'Squada One', cursive; color: #3b82f6; font-size: 2.2rem; line-height: 1.0; text-align: center; }
        .main-btn { background-color: #1e3a8a; border: 2px solid #3b82f6; border-radius: 12px; height: 70px; display: flex; align-items: center; justify-content: center; width: 100%; margin: 8px 0; cursor: pointer; }
        .result-card { background-color: #0f172a; border-radius: 12px; padding: 12px; border: 1px solid #1e293b; margin-bottom: 8px; }
        .bar-bg { background-color: #020617; height: 10px; border-radius: 4px; overflow: hidden; margin-top: 4px; border: 1px solid #1e293b; }
        .bar-fill { height: 100%; width: 0%; transition: width 0.4s; }
        .future-log { background-color: #000; border: 1px solid #3b82f6; border-radius: 8px; padding: 10px; font-family: 'Share Tech Mono', monospace; font-size: 10px; flex-grow: 1; overflow-y: auto; white-space: pre-wrap; word-break: break-all; color: #4ade80; }
        .api-input { background-color: #0f172a; color: #fff; border: 1px solid #1e293b; padding: 8px; font-size: 12px; flex-grow: 1; border-radius: 4px; }
        .set-1 { color: #22d3ee; } .bar-1 { background-color: #22d3ee; }
        .set-2 { color: #facc15; } .bar-2 { background-color: #facc15; }
        .set-5 { color: #4ade80; } .bar-5 { background-color: #4ade80; }
        .set-6 { color: #f87171; } .bar-6 { background-color: #f87171; }
    </style>
</head>
<body>
    <div class="kawaii-title uppercase">HANABI & VERSUS</div>
    <div class="text-center text-[10px] text-blue-500 font-bold mb-2">Rev 1.2.14 (Pointer Priority)</div>

    <label for="file-input" class="main-btn"><span>ユニメモ画像解析</span></label>
    <input type="file" id="file-input" class="hidden" accept="image/*" multiple>

    <div id="result-area" class="result-card">
        <div class="grid grid-cols-2 gap-4">
            <div><div class="flex justify-between text-[11px] set-1"><span>設定1</span><span id="p1">-</span></div><div class="bar-bg"><div id="b1" class="bar-fill bar-1"></div></div></div>
            <div><div class="flex justify-between text-[11px] set-2"><span>設定2</span><span id="p2">-</span></div><div class="bar-bg"><div id="b2" class="bar-fill bar-2"></div></div></div>
            <div><div class="flex justify-between text-[11px] set-5"><span>設定5</span><span id="p5">-</span></div><div class="bar-bg"><div id="b5" class="bar-fill bar-5"></div></div></div>
            <div><div class="flex justify-between text-[11px] set-6"><span>設定6</span><span id="p6">-</span></div><div class="bar-bg"><div id="b6" class="bar-fill bar-6"></div></div></div>
        </div>
    </div>

    <div id="log" class="future-log">READY...</div>

    <div class="flex gap-2 mt-2">
        <input type="password" id="api-key" class="api-input" placeholder="VISION API KEY">
        <button id="save-key" class="bg-blue-900 px-4 rounded text-[11px]">SAVE</button>
    </div>

    <script>
        const CONFIG_NEW_HANABI = [
            { id: "don_bb", name: "ドンBB", active: false },
            { id: "red7_bb", name: "赤七BB", active: false },
            { id: "bb_total", name: "BB合算", active: true, probs: {1: 287.4, 2: 277.7, 5: 268.6, 6: 256.0} },
            { id: "rb_total", name: "RB", active: true, probs: {1: 356.2, 2: 331.0, 5: 306.2, 6: 282.5} },
            { id: "f_gassan", name: "風鈴合算", active: false },
            { id: "f_a", name: "風鈴A", active: true, probs: {1: 15.6, 2: 15.3, 5: 15.1, 6: 14.9} },
            { id: "f_b", name: "風鈴B", active: true, probs: {1: 15.3, 2: 14.9, 5: 14.7, 6: 13.8} },
            { id: "i_gassan", name: "氷合算", active: false },
            { id: "i_a", name: "氷A", active: true, probs: {1: 54.6, 2: 59.6, 5: 51.2, 6: 54.6} },
            { id: "i_b", name: "氷B", active: false },
            { id: "c_gassan", name: "チェリー合算", active: false },
            { id: "c_a1", name: "チェリーA1", active: false },
            { id: "c_a2", name: "チェリーA2", active: true, probs: {1: 21.0, 2: 19.3, 5: 20.6, 6: 19.9} },
            { id: "c_b", name: "チェリーB", active: true, probs: {1: 282.5, 2: 281.3, 5: 276.5, 6: 274.2} },
            { id: "hc_hazure", name: "HCハズレ", active: true, probs: {1: 6.6, 2: 6.2, 5: 5.8, 6: 5.3} },
            { id: "hg_hazure", name: "HGハズレ", active: true, probs: {1: 11.7, 2: 10.8, 5: 10.0, 6: 9.4} },
            { id: "bb_parallel", name: "BIG中平行", active: false },
            { id: "bb_slant", name: "BIG中斜め", active: true, probs: {1: 11.0, 2: 9.0, 5: 11.0, 6: 9.0} }
        ];

        async function processAnalysis(files) {
            const key = document.getElementById('api-key').value;
            const logDiv = document.getElementById('log');
            logDiv.innerHTML = "--- START ANALYSIS Rev 1.2.14 ---\n";
            const addLog = (m) => { logDiv.innerText += m + "\n"; logDiv.scrollTop = logDiv.scrollHeight; };

            let totalG = 0;
            let masterData = []; // {k, p, finger, imgIdx}

            try {
                for (let i = 0; i < files.length; i++) {
                    addLog(`[OCR] IMG_${i} 読込中...`);
                    const base64 = await new Promise(r => { const reader = new FileReader(); reader.onload = e => r(e.target.result.split(',')[1]); reader.readAsDataURL(files[i]); });
                    const res = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${key}`, {
                        method: 'POST',
                        body: JSON.stringify({ requests: [{ image: { content: base64 }, features: [{ type: 'DOCUMENT_TEXT_DETECTION' }] }] })
                    });
                    const json = await res.json();
                    const lines = json.responses[0].fullTextAnnotation.text.split('\n');

                    // 総プレイ数取得
                    if (totalG === 0) {
                        const gLine = lines.find(l => l.includes('G'));
                        if (gLine) totalG = parseInt(gLine.replace(/[^0-9]/g, ''));
                    }

                    // 3点セット（回数・指紋・確率）の抽出
                    for (let j = 0; j < lines.length; j++) {
                        if (lines[j].includes('/') && lines[j].includes('.')) {
                            const pStr = lines[j].match(/1\s*\/\s*([\d.]+)/)?.[1] || lines[j].match(/([\d.]+)/)?.[1];
                            const kLine = lines[j - 2];
                            const finger = lines[j - 1];

                            if (pStr && kLine && kLine.includes('回')) {
                                const kVal = parseInt(kLine.replace(/[^0-9]/g, ''));
                                const pVal = parseFloat(pStr);
                                
                                // 重複チェック: 確率kと回数pが一致するかを最優先
                                const isDupe = masterData.some(d => d.k === kVal && d.p === pVal);
                                if (!isDupe) {
                                    masterData.push({ k: kVal, p: pVal, finger: finger, imgIdx: i });
                                    addLog(`  [FOUND] k:${kVal} p:1/${pVal} (Finger: ${finger})`);
                                } else {
                                    // 確率・回数が同じでも指紋が全然違う場合のみ別データと検討するが、基本はポインタ優先でスキップ
                                    addLog(`  [SKIP] 重複(k:${kVal} p:1/${pVal})`);
                                }
                            }
                        }
                    }
                }

                addLog(`(3) 総ゲーム数: ${totalG}G`);
                addLog(`(4) ポインタ走査・スロット割当:`);

                let results = {};
                let slotIdx = 0;

                // 抽出したmasterDataを、定義表の上から順に割り当てる
                masterData.forEach((data, dIdx) => {
                    while (slotIdx < CONFIG_NEW_HANABI.length) {
                        const conf = CONFIG_NEW_HANABI[slotIdx];
                        // 物理的計算チェック（通常時G数と矛盾しないか）
                        const nCalc = data.k * data.p;
                        const isNormal = Math.abs(nCalc - totalG) < (totalG * 0.05);
                        
                        // 特殊区間（HC/HG/BIG中）の項目かどうかの判定
                        const isSpecial = ["hc_hazure", "hg_hazure", "bb_parallel", "bb_slant"].includes(conf.id);

                        if (isNormal !== isSpecial) {
                            results[conf.id] = { k: data.k, p: data.p, n: Math.round(nCalc) };
                            addLog(`  [ADOPT] Slot[${slotIdx}] ${conf.name} <- k:${data.k} p:1/${data.p}`);
                            slotIdx++;
                            return;
                        }
                        addLog(`  [NEXT] Slot[${slotIdx}] ${conf.name} スキップ (計算不一致)`);
                        slotIdx++;
                    }
                });

                // 尤度計算
                let lls = { 1: 0, 2: 0, 5: 0, 6: 0 };
                CONFIG_NEW_HANABI.forEach(conf => {
                    if (results[conf.id] && conf.active) {
                        const res = results[conf.id];
                        [1, 2, 5, 6].forEach(s => {
                            const tp = 1 / conf.probs[s];
                            lls[s] += res.k * Math.log(tp) + (res.n - res.k) * Math.log(1 - tp);
                        });
                    }
                });

                const maxLL = Math.max(...Object.values(lls));
                const sumExp = Object.values(lls).reduce((a, b) => a + Math.exp(b - maxLL), 0);
                [1, 2, 5, 6].forEach(s => {
                    const prob = (Math.exp(lls[s] - maxLL) / sumExp) * 100;
                    document.getElementById(`p${s}`).innerText = prob.toFixed(2) + "%";
                    document.getElementById(`b${s}`).style.width = prob + "%";
                });
                addLog(`(6) 解析完了`);

            } catch (e) {
                addLog(`❌ ERROR: ${e.message}`);
            }
        }

        document.getElementById('file-input').onchange = e => processAnalysis(e.target.files);
        document.getElementById('save-key').onclick = () => { localStorage.setItem('v_key', document.getElementById('api-key').value); alert('SAVED'); };
        window.onload = () => { document.getElementById('api-key').value = localStorage.getItem('v_key') || ''; };
    </script>
</body>
</html>