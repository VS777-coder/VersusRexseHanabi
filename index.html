<script>
// ... (CONFIG„Éá„Éº„Çø„ÅØÁ∂ôÊâø) ...

async function analyze(file) {
    const key = document.getElementById('api-key').value.trim();
    if (!key) return alert('API KEY missing');
    document.getElementById('log').innerText = "READY...";
    await addLog(">> ANALYSIS STARTING...", 200);

    const reader = new FileReader(); 
    reader.readAsDataURL(file);
    reader.onload = async () => {
        const res = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${key}`, {
            method: 'POST', body: JSON.stringify({ requests: [{ image: { content: reader.result.split(',')[1] }, features: [{ type: 'DOCUMENT_TEXT_DETECTION' }] }] })
        });
        const json = await res.json();
        const raw = json.responses[0]?.textAnnotations;
        if(!raw) return addLog("OCR error.");

        const rawWords = raw.slice(1);
        let rows = [];
        rawWords.forEach(w => {
            let y = w.boundingPoly.vertices[0].y;
            let f = rows.find(r => Math.abs(r.y - y) < 10);
            if (f) { f.words.push(w); } else { rows.push({ y, words: [w] }); }
        });

        const sortedLines = rows.sort((a,b)=>a.y-b.y).map(r => {
            return r.words.sort((a,b)=>a.boundingPoly.vertices[0].x - b.boundingPoly.vertices[0].x).map(w=>w.description).join(" ");
        });

        // „ÄêÊåáÁ§∫È†ÖÁõÆ1„Äë„Åó„Åç„ÅÑÂÄ§10„ÅßÂèñ„Å£„ÅüÂÖ®Ë°å„ÅÆÁîü„Éá„Éº„ÇøÂá∫Âäõ
        await addLog("\n--- (2) THRESHOLD DATA (10px) ---");
        sortedLines.forEach((line, idx) => {
            addLog(`[L-${idx.toString().padStart(3,'0')}] Y-POS | ${line}`);
        });

        let currentConfig = null;
        const fullText = sortedLines.join("");
        if (fullText.match(/„Éè„Éä„Éì|„Éâ„É≥|Ëä±ÁÅ´/)) { currentConfig = HANABI_CONFIG; await addLog("\n>> MODE: HANABI üéÜ"); }
        else if (fullText.match(/„Éê„Éº„Çµ„Çπ|Ôº∂Ôº•Ôº≤Ôº≥ÔºµÔº≥/)) { currentConfig = VERSUS_CONFIG; await addLog("\n>> MODE: VERSUS ‚ö°"); }
        if (!currentConfig) return await addLog("‚ùå ERROR: Ê©üÁ®ÆÁâπÂÆö‰∏çËÉΩ„ÄÇ");

        let totalG = 0; let startParsing = false; let startIndex = 0;
        for (let i = 0; i < Math.min(sortedLines.length, 10); i++) {
            const line = sortedLines[i].replace(/\s/g, '');
            if (line.includes("Á∑è„Éó„É¨„Ç§Êï∞") && line.match(/[GÔºß]/)) {
                let gMatch = line.match(/([\d,]+)/);
                if (gMatch) {
                    totalG = parseInt(gMatch[1].replace(/,/g, ''));
                    startParsing = true; startIndex = i;
                    await addLog(`[START] TotalG: ${totalG}G üÜó`);
                    break;
                }
            }
        }
        if (!startParsing) return await addLog("‚ùå ERROR: Á∑è„Éó„É¨„Ç§Êï∞Êú™Ê§úÂá∫„ÄÇ");

        await addLog("\n--- (3) DATA MAPPING ---");
        let configPtr = 0; let extractedData = [];
        for (let i = startIndex + 1; i < sortedLines.length; i++) {
            const line = sortedLines[i];
            if (!line.includes("/") || configPtr >= currentConfig.length) continue;

            const item = currentConfig[configPtr];
            let probMatch = line.match(/1\s*\/\s*([\d,.]+)/);
            if (!probMatch) continue;

            let pVal = parseFloat(probMatch[1].replace(/,/g, ''));
            let cVal = 0;
            for (let offset = 1; offset <= 3; offset++) {
                if (i - offset >= 0 && sortedLines[i - offset].includes("Âõû")) {
                    let cMatch = sortedLines[i - offset].match(/([\d,]+)/);
                    if (cMatch) { cVal = parseInt(cMatch[1].replace(/,/g, '')); break; }
                }
            }
            await addLog(`> [${item.name}] Ë™çË≠òË°å: "${line}" | ${cVal}Âõû | 1/${pVal}`);
            extractedData.push({ item, k: cVal, p_ocr: pVal });
            configPtr++;
        }

        await addLog("\n--- (4) LIKELIHOOD CALC ---");
        let logLikelihoods = { 1:0, 2:0, 5:0, 6:0 };
        const rtIds = ['vc', 'vg', 'nf', 'vc_miss', 'vg_miss', 'cb_hit', 'cb_miss'];

        for (const d of extractedData) {
            if (d.item.active && totalG > 0) {
                let n = rtIds.includes(d.item.id) ? Math.round(d.k * d.p_ocr) : totalG;
                let lineLog = `[L-CALC] ${d.item.name.padEnd(8,' ')} | n=${String(n).padEnd(5,' ')} `;
                [1,2,5,6].forEach(s => {
                    let p = 1 / d.item.probs[s];
                    let L = (d.k * Math.log(p) + (n - d.k) * Math.log(1 - p));
                    logLikelihoods[s] += L;
                    lineLog += `S${s}:${L.toFixed(1)} `;
                });
                await addLog(lineLog);
            }
        }

        // „ÄêÊåáÁ§∫È†ÖÁõÆ2„ÄëÂà§Âà•ÁµêÊûú„ÅÆÔºÖ„Çí„É≠„Ç∞„Å´Êï∞ÂÄ§„ÅßÂá∫Âäõ
        await addLog("\n--- (5) FINAL RESULT ---");
        const maxLL = Math.max(...Object.values(logLikelihoods));
        const exps = Object.fromEntries(Object.entries(logLikelihoods).map(([s, l]) => [s, Math.exp(l - maxLL)]));
        const sumExps = Object.values(exps).reduce((a,b)=>a+b, 0);
        
        [1,2,5,6].forEach(s => {
            let pct = ((exps[s] / sumExps) * 100).toFixed(1);
            document.getElementById(`p${s}`).innerText = `${pct}%`;
            document.getElementById(`b${s}`).style.width = `${pct}%`;
            addLog(`Ë®≠ÂÆö${s}: ${pct}%`); // „É≠„Ç∞„Å∏„ÅÆÂá∫Âäõ
        });
        await addLog("\nANALYSIS COMPLETE.");
    };
}
</script>